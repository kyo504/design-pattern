// 총정리

// 디자인 패턴의 핵심
// 1. 공통성과 가변성의 분리 - 변하지 않는 전체 알고리즘에서
//                             변하는 것을 뽑아내는 것.

//   A. 변하는 것을 가상 함수로 분리
//             - 자식 클래스에서 가상함수를 재정의
//      "Template Method": 알고리즘이나 정책을 변경
//      "Factory Method": 어떤 클래스의 인스턴스를 생성할지를 결정

//       "편리하지만, 정적인 변화 - 실행 시간에 정책을 교체 하는 것이 불가능하다."
//       "정책을 다른 클래스에서 사용하는 것이 불가능하다."

//   B. 변하는 것을 다른 클래스로 
//      - 교체 가능해야 하므로 인터페이스 기반으로
//       "Strategy": 알고리즘의 캡슐화
//       "State"   : 상태에 따른 동작의 변경
//       "Builder" : 같은 공정이지만 다른 표현의 객체를 생성할 때
//             - 다른 형태로 사용되는 경우가 많다.

//        "실행 시간에 교체 가능하다. 정책을 다른 클래스에서 재사용 가능하다."

//     - 템플릿 인자를 통한 정책 클래스의 교체 방법
//       실행 시간에 교체는 불가능하지만 인라인 치환이 가능하므로 성능이 좋다.
//       stack<int, list<int>> / List<int, SingleThread> 

//-------------------------------------------------------------
// 2. 간접층을 도입함으로써 문제를 해결하는 패턴
//   - Adapter: 클라이언트가 요구하는 클래스를 기존 클래스의 인터페이스를 변경해서 제공
//   - Proxy: 기존 요소를 대신 클래스 (Remote Proxy, Smart Proxy)
//   - Bridge: 구현부와 추상부를 독립적으로 변경 가능하게 하겠다.
//   - Facade: 하위 시스템의 복잡함을 단순화 해주는 개념
//   - Mediator: 복잡한 객체 간의 관계를 단순화 시켜준다.
//   - Command: 명령을 추상화. undo, redo, macro

// 3. A와 B를 묶기 위해서는 공통의 부모가 필요하다.
//   - 재귀적 합성을 사용하고 패턴 2가지
//   - Composite: 재귀적 합성을 통한 복합 객체의 구성
//   - Decorator: 재귀적 합성을 통한 기능의 추가

// 4. 복합 객체(컨테이너) 연관된 패턴 2가지
//  - Iterator: 복합 객체의 내부 구조에 상관없이 요소를 열거
//  - Visitor: 복합 객체의 내부 구조에 상관없이 요소에 연산

// 5. 이벤트 처리에 관련된 패턴 2가지
// - Observer: 이벤트가 발생하였을 경우 등록된 객체에게 전파
// - Chain of Responsibility:  "        다음 객체에게 전달

// 6. C++ Idioms
//   RAII, CRTP, STL, algorithm, function, this template, 통보 센터
//------------------------------------------------------------

// 디자인 패턴 23가지
// 생성 5가지: 싱글톤, 추상 팩토리, 팩토리 메소드, 빌더, 프로토 타입
// 구조 7가지: 어댑터, 프록시, 브릿지, 퍼사드
//             컴포지트, 데코레이터
//             플라이웨이트(불변 객체)
// 행위 11가지: 반복자, 방문자
//              관찰자, 책임의 전가
//              템플릿 메소드, 전략, 상태
//              커맨드, 메멘토, 중재자, 인터프리터
                
// 결국 가장 중요한 것은 객체 지향의 5대 원칙
// SRP(단일 책임의 원칙) - 모듈은 단 하나의 책임을 가져야한다.
// OCP(개방 폐쇄의 원칙) - 새로운 기능이 추가되어도 확장에는 열려 있어야 한다.
// LSP(리스코프 치환 원칙) - 자식의 공통된 기능은 부모로부터 와야 한다.
// ISP(인터페이스 분리 원칙) - 범용 인터페이스 보다는 세분화된 인터페이스가 낫다.
// DIP(의존 관계 역전 원칙) - 클라이언트는 구체 클래스에 의존하는 것이 아니라
//                            인터페이스나 추상 클래스에 의존해야 한다.
